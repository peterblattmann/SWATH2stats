#' Calculate the fdr hit rates for every sample in the data.
#'
#' This function calculates some metrics which describe how often each sample
#' passes the given m score thresholds.  Optionally it may also plot some of
#' these statistics.
#'
#' @param data  Data structure generated by sample_annotation()
#' @param FFT I have read the code for this function a few times now and I still
#'   do not know what this refers to.  I am going to say 'fast fourier
#'   transform', which is obviously not true.  I can say that it is a factor
#'   which is used to change the fdr_cube data, which is very much not the same
#'   thing as an answer.
#' @param  n_range  I am also not certain what this is, nor why 20 is the
#'   optimal default value, but I think the idea is to set up a series of mscore
#'   thresholds.
#' @param output  Send the result of this to a pdf/csv or the R console?
#' @param plot  Make some pretty bar plots of the results?
#' @param filename  Where to send the pdf/csv report (it seems to me this should
#'   be folded into the output parameter).
#' @param output_mscore_levels  Character list with some predefined thresholds.
#' @export
assess_fdr_byrun <- function(data, FFT=1, n_range=20, output="pdf_csv", plot=TRUE,
                             filename="FDR_report_byrun", output_mscore_levels=c(0.01, 0.001)) {
  ## create m_score intervals to be tested
  test_levels <- 10 ^ -seq(1:n_range)

  ## Identify the minimal m-score cutoff at which all runs still contain decoys
  decoy_count_lengths <- NULL
  for (i in seq(1:n_range)) {
    decoy_count_lengths[i] <- length(by(data[data[["decoy"]] == TRUE &
                                             data[["m_score"]] <= test_levels[i],
                                             c("transition_group_id")],
                                        data[data[["decoy"]] == TRUE &
                                             data[["m_score"]] <= test_levels[i],
                                             c("run_id")],
                                        length))
  }

  mscore_limit <- length(
    decoy_count_lengths[decoy_count_lengths == length(unique(data[["run_id"]]))])

  if (mscore_limit < 2) {
    mscore_limit <- 2
  }

  mscore_levels <- 10 ^ -c(seq(2, mscore_limit))
  output_mscore_levels <- output_mscore_levels[output_mscore_levels %in% mscore_levels]

  fdr_cube <- array(NA, dim=c(12, length(unique(data[["run_id"]])), length(mscore_levels)))

  dimnames(fdr_cube) <- list(c("target_assays", "decoy_assays", "false_target_assays",
        "assay_fdr", "target_peptides", "decoy_peptides", "false_target_peptides", "peptide_fdr",
        "target_proteins", "decoy_proteins", "false_target_proteins", "protein_fdr"),
        sort(unique(data[["run_id"]])), mscore_levels)

  length_unique <- function(X) {
    length(unique(X))
  }

  data.t <- data[data[["decoy"]] == 0, ]
  data.d <- data[data[["decoy"]] == 1, ]

  ## for each m_score cutoff in mscore_levels, count targets and decoys and calculate false targets and fdr
  for (i in sql_len(length(mscore_levels))) {
    ## for each run_id, count target (and decoy) assays identified ("id" column entries)
    ## and store in pane i /row 1 (targets) /row 2 (decoys) & calculate false targets & fdr based on FFT
    fdr_cube[1, , i] <- by(data.t[data.t[["m_score"]] <= mscore_levels[i], c("transition_group_id")],
                           data.t[data.t[["m_score"]] <= mscore_levels[i], c("run_id")], length)
    fdr_cube[2, , i] <- by(data.d[data.d[["m_score"]] <= mscore_levels[i], c("transition_group_id")],
                           data.d[data.d[["m_score"]] <= mscore_levels[i], c("run_id")], length)

    fdr_cube[3, , i] <- fdr_cube[2, , i] * FFT
    fdr_cube[4, , i] <- fdr_cube[3, , i] / fdr_cube[1, , i]

    ## for each run_id, count target (and decoy) peptides identified (unique "FullPeptideName" column entries)
    ## and store in pane i /row 1 (targets) /row 2 (decoys) & calculate false targets & fdr based on FFT
    fdr_cube[5, , i] <- by(data.t[data.t[["m_score"]] <= mscore_levels[i],
                                  c("fullpeptidename")],
                           data.t[data.t[["m_score"]] <= mscore_levels[i],
                                  c("run_id")], length_unique)
    if (nrow(data.d) > 0) {
      fdr_cube[6, , i] <- by(data.d[data.d[["m_score"]] <= mscore_levels[i],
                                    c("fullpeptidename")],
                             data.d[data.d[["m_score"]] <= mscore_levels[i],
                                    c("run_id")], length_unique)
    } else {
      tmp_cube <- fdr_cube[5, , i]
      for (c in 1:length(tmp_cube)) {
        tmp_cube[c] <- 0
      }
      fdr_cube[6, , i] <- tmp_cube
    }
    fdr_cube[7, , i] <- fdr_cube[6, , i] * FFT
    fdr_cube[8, , i] <- fdr_cube[7, , i] / fdr_cube[5, , i]

    ## for each run_id, count target (and decoy) proteins identified (unique "ProteinName" column entries)
    ## and store in pane i / row 1 (targets) / row 2 (decoys) & calculate false targets & fdr based on FFT
    fdr_cube[9, , i] <- by(data.t[data.t[["m_score"]] <= mscore_levels[i],
                                  c("proteinname")],
                           data.t[data.t[["m_score"]] <= mscore_levels[i],
                                  c("run_id")], length_unique)
    if (nrow(data.d) > 0) {
      fdr_cube[10, , i] <- by(data.d[data.d[["m_score"]] <= mscore_levels[i],
                                     c("proteinname")],
                              data.d[data.d[["m_score"]] <= mscore_levels[i],
                                     c("run_id")], length_unique)
    } else {
      tmp_cube <- fdr_cube[9, , i]
      for (c in 1:length(tmp_cube)) {
        tmp_cube[c] <- 0
      }
      fdr_cube[10, , i] <- tmp_cube
    }
    fdr_cube[11, , i] <- fdr_cube[10, , i] * FFT
    fdr_cube[12, , i] <- fdr_cube[11, , i] / fdr_cube[9, , i]
  }

  ## print fdr values to console (m_score cutoff 1e-2)
  message("The average FDR by run on assay level is ", round(mean(fdr_cube[4, , 1], na.rm=TRUE), digits=3))
  message("The average FDR by run on peptide level is ", round(mean(fdr_cube[8, , 1], na.rm=TRUE), digits=3))
  message("The average FDR by run on protein level is ", round(mean(fdr_cube[12, , 1], na.rm=TRUE), digits=3))

  if (output == "pdf_csv") {
    message("Individual run FDR qualities can be retrieved from ", paste0(filename, ".csv"))
    ## Write csv reports for mscore 1e-2 and 1e-3

    for (i in output_mscore_levels) {
      k.mscore <- which(dimnames(fdr_cube)[[3]] == i)
      k.mscore.label <- as.numeric(dimnames(fdr_cube)[[3]][k.mscore])
      write.csv(fdr_cube[, , k.mscore], file=paste0(filename, "table_mscore_",
                                                    format(k.mscore.label, scientific=TRUE), ".csv"))
    }
    message(filename, ".csv reports written to working folder.")
  }

  fdr_cube2 <- fdr_cube
  class(fdr_cube2) <- "fdr_cube"

  if (isTRUE(plot)) {
    plot_fdr_cube(fdr_cube2, output=output, filename=filename,
                  plot_mscore_levels=output_mscore_levels)
  }

  return(fdr_cube2)
}
